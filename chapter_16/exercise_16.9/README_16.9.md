# Упражнение по программированию 16.9  
По сравнению с массивом связный список отличается более простым добавлением и  
удалением элементов, но медленной сортировкой. Поэтому возникает вопрос:  
возможно, было бы быстрее скопировать список в массив, отсортировать массив  
и скопировать отсортированный результат обратно в список, чем просто  
использовать алгоритм списка для сортировки. (Но это может быть связано с  
наличием большего объёма памяти.) Проверьте гипотезу о более быстром выполнении  
задачи, применив следующий подход.  
  1. Создайте большой объект `vi0` типа `vector<int>`, используя `rand()` для  
  задания начальных значений.
  2. Создайте второй объект `vi` типа `vector<int>` и объект `li` типа  
  `list<int>` того же размера, что и исходный, и инициализируйте их значениями  
  исходного вектора.  
  3. Замерьте время, требуемое программе для сортировки `vi` с помощью  
  алгоритма `sort()` из `STL`, а затем время, необходимое для сортировки `li`  
  посредством метода `list_sort()`.  
  4. Переустановите `li` неотсортированным содержимым `vi0`. Замерьте время  
  выполнения смешанной операции копирования `li` в `vi`, сортировки `vi` и  
  копирования результата обратно в `li`.

Для измерения времени выполнения этих операций можно использовать `clock()` из  
библиотеки `ctime`. Как показано в листинге 5.14, для запуска первого таймера  
можно применять следующий оператор:  
```cpp
  clock_t start = clock();
```
Для получения прошедшего времени в конце операции используйте следующий  
оператор:  
```cpp
  clock_t end = clock();
  std::cout << (double)(end - start) / CLOCKS_PER_SEC;
```
Вне всяких сомнений, этот тест показателен, поскольку результаты будут зависеть  
от ряда факторов, в том числе объёма доступной памяти, применения  
многопроцессорной обработки и размеров массива или списка. (С увеличением  
количества сортируемых элементов можно ожидать большего увеличения  
эффективности массива по сравнению со списком.) Кроме того, при наличии выбора  
между стандартной сборкой и окончательной сборкой, следует выбирать  
окончательную сборку. В современных высокоскоростных компьютерах для получения  
репрезентативных результатов необходимо использовать массив максимально  
возможного размера. Например, можно иметь 100000, 1000000 и 10000000  
элементов.  
